#!/usr/bin/env python3
##############################################################################
## This file is part of 'axi-soc-ultra-plus-core'.
## It is subject to the license terms in the LICENSE.txt file found in the
## top-level directory of this distribution and at:
##    https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
## No part of 'axi-soc-ultra-plus-core', including this file,
## may be copied, modified, propagated, or distributed except according to
## the terms contained in the LICENSE.txt file.
##############################################################################

import rogue
import rogue.hardware.axi
import rogue.interfaces.memory

import pyrogue
import pyrogue.interfaces

import subprocess
import time
import argparse
import shutil

rogue.Version.minVersion('6.5.0')

# rogue.Logging.setLevel(rogue.Logging.Debug)

#################################################################

class RfdcApi(pyrogue.interfaces.OsCommandMemorySlave):

    def __init__(self):
        super().__init__()

        # Local cached variables
        self.mstAdc = 0
        self.mstDac = 0

        @self.command(base=pyrogue.UInt(8), addr=0x00)
        def MstAdcTiles(self, arg):
            try:
                # Write operation
                if arg is not None:
                    command = ['rfdc-mst', 'adc', f'--tiles={int(arg)}']
                    result = subprocess.run(command, text=True)

                    # Store only the return code
                    self.mstAdc = result.returncode

                # Read operation
                else:
                    return self.mstAdc

            except Exception as e:
                print(f"Error executing command: {e}", file=sys.stderr)
                self.mstAdc = 0

        @self.command(base=pyrogue.UInt(8), addr=0x04)
        def MstDacTiles(self, arg):
            try:
                # Write operation
                if arg is not None:
                    command = ['rfdc-mst', 'dac', f'--tiles={int(arg)}']
                    result = subprocess.run(command, text=True)

                    # Store only the return code
                    self.mstDac = result.returncode

                # Read operation
                else:
                    return self.mstDac

            except Exception as e:
                print(f"Error executing command: {e}", file=sys.stderr)
                self.mstDac = 0

#################################################################

class ZynqTcpServer(object):
    def __init__(self,numLane,numDest):

        # Memory server on port [9000:9001]
        print( 'Starting Memory TcpServer at Port=9000')
        self.memMap = rogue.hardware.axi.AxiMemMap('/dev/axi_memory_map')
        self.memServer = rogue.interfaces.memory.TcpServer('*', 9000)
        self.memServer >> self.memMap

        # Data server on port [10000+512*lane+2*tdest:10000+512*lane+2*tdest+1]
        self.dmaStream = [[None for x in range(numDest)] for y in range(numLane)]
        self.dataServer = [[None for x in range(numDest)] for y in range(numLane)]
        for lane in range(numLane):
            for tdest in range(numDest):
                port = 10000+512*lane+2*tdest
                print( f'Starting Stream TcpServer at Port={port} and Port={port+1} for DMA[{lane}][{tdest}]' )
                self.dmaStream[lane][tdest] = rogue.hardware.axi.AxiStreamDma('/dev/axi_stream_dma_0', 256*lane+tdest, True)
                self.dataServer[lane][tdest] = rogue.interfaces.stream.TcpServer('*',port)
                self.dmaStream[lane][tdest] == self.dataServer[lane][tdest]

        # Check if the RFDC API interface exists
        if shutil.which('rfdc-mst'):

            # Memory server on port [9002:9003]
            self.apiMap = rogue.interfaces.memory.TcpServer('*', 9002)
            self.rfdcApi = RfdcApi()
            self.apiMap >> self.rfdcApi

#################################################################

if __name__ == "__main__":

    #################################################################

    # Set the argument parser
    parser = argparse.ArgumentParser()

    ##############################################################################
    ## Refer to https://jira.slac.stanford.edu/browse/ESROGUE-549 if you want to
    ## have more than 100 TCP streams.  That JIRA ticket explains how to configure
    ## the kernel to support all 2048 possible lanes (8 DMA lanes x 256 TDEST)
    ##############################################################################

    # Add arguments
    parser.add_argument(
        "--lane",
        type     = int,
        required = False,
        default  = 2,
        help     = "# of DMA Lanes",
    )

    parser.add_argument(
        "--tdest",
        type     = int,
        required = False,
        default  = 32,
        help     = "# of TDEST per lane",
    )

    # Get the arguments
    args = parser.parse_args()

    #################################################################

    def eth0_ready():
        command = 'ip -4 -o addr show eth0'.split()
        return (subprocess.check_output(command).decode() != '')

    # Wait for NIC to be ready
    while(eth0_ready() is False):
        print('Waiting for eth0 to get IP address')
        time.sleep(5.0)

    #################################################################

    # Create the TCP bridge
    server = ZynqTcpServer(numLane=args.lane, numDest=args.tdest)
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print('Stopping TcpServers')

    #################################################################
